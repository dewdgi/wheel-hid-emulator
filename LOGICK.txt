=============================================================================
WHEEL-EMULATOR ARCHITECTURE
=============================================================================

PURPOSE: Transform keyboard+mouse into Xbox 360 gamepad for racing games
DESIGN: Simple C++ using Linux uinput/evdev APIs

=============================================================================
ARCHITECTURE
=============================================================================

FILES
-----
Makefile          - Build configuration
src/
  main.cpp        - Entry point, main loop, signal handling, device detection
  config.h/cpp    - Configuration loading with device paths
  input.h/cpp     - Keyboard/mouse reading, device discovery
  gamepad.h/cpp   - Virtual gamepad device

COMPONENTS
----------
Config:
  - Loads INI file from /etc/wheel-emulator.conf ONLY
  - Stores sensitivity, device paths, and button mappings
  - Auto-generates default if missing
  - Can update device paths via UpdateDevices()

Input:
  - Discovers devices via explicit paths (from config) OR auto-detection
  - Reads events into key state map
  - Detects Ctrl+M toggle
  - Grabs/ungrabs devices

Gamepad:
  - Creates virtual Xbox 360 controller via /dev/uinput
  - Manages state (steering, throttle, brake, buttons)
  - Sends events to virtual device
  - Standard Xbox 360 axis mapping:
    * ABS_X/Y:   Left stick (X = steering, Y = unused/0)
    * ABS_RX/RY: Right stick (unused, both 0)
    * ABS_Z:     Left trigger (brake, 0-255)
    * ABS_RZ:    Right trigger (throttle, 0-255)
    * ABS_HAT0X/Y: D-Pad

=============================================================================
PROGRAM FLOW
=============================================================================

Detection Mode (--detect flag):
  1. Check root privileges
  2. Open all /dev/input/event* devices
  3. Filter devices by capabilities (keyboard keys, REL_X for mouse)
  4. Monitor keyboard devices for 5 seconds while user types
  5. Count key press events per device
  6. Monitor mouse devices for 5 seconds while user moves mouse
  7. Count REL_X movement events per device
  8. Select devices with most events as best candidates
  9. Automatically update /etc/wheel-emulator.conf with detected paths
  10. Exit

Normal Mode:
  1. Check root privileges
  2. Load config from /etc/wheel-emulator.conf (create if missing)
  3. Create virtual gamepad (/dev/uinput)
  4. Discover keyboard:
     - If keyboard_device path in config: use it directly
     - Otherwise: auto-detect (priority-based search)
  5. Discover mouse:
     - If mouse_device path in config: use it directly
     - Otherwise: auto-detect (priority-based search)
  6. Start with emulation disabled (devices NOT grabbed)

Main Loop:
  1. Read keyboard events → update key map
  2. Read mouse events → accumulate delta_x
  3. Check for Ctrl+M toggle
     - If toggled ON:  grab devices, enable emulation
     - If toggled OFF: ungrab devices, disable emulation
  4. If enabled:
       - Update steering (accumulative, sensitivity-scaled)
       - Update throttle/brake (analog ramping)
       - Update buttons and D-Pad
       - Send gamepad state
     Else:
       - Send neutral state
  5. Sleep 1ms
  6. Repeat

Cleanup (Ctrl+C):
  - Ungrab devices (if grabbed)
  - Close file descriptors (RAII)
  - Exit

=============================================================================
IMPLEMENTATION DETAILS
=============================================================================

CONFIG (config.h/cpp)
---------------------
struct Config {
    int sensitivity = 20;
    std::string keyboard_device;  // e.g. "/dev/input/event6"
    std::string mouse_device;     // e.g. "/dev/input/event11"
    std::map<std::string, int> button_map;
    
    bool Load();  // Loads from /etc/wheel-emulator.conf only
    void SaveDefault(const char* path);
    bool UpdateDevices(kbd_path, mouse_path);  // Update config with detected devices
};

File location: /etc/wheel-emulator.conf ONLY (no ~/.config fallback)
INI format sections:
  [devices]         - keyboard=/dev/input/eventX, mouse=/dev/input/eventY
  [sensitivity]     - sensitivity=20
  [button_mapping]  - KEY_Q=BTN_A, etc.
Auto-generates default if missing
Validation: Sensitivity clamped to range [1, 100] during parsing
Supported buttons: BTN_A, BTN_B, BTN_X, BTN_Y, BTN_TL, BTN_TR, 
                   BTN_SELECT, BTN_START, BTN_THUMBL, BTN_THUMBR, BTN_MODE

INPUT (input.h/cpp)
-------------------
class Input {
    int kbd_fd, mouse_fd;
    bool keys[KEY_MAX] = {false};  // Direct array indexed by KEY_* codes
    bool prev_toggle = false;
    
    bool DiscoverKeyboard(device_path = "");  // Use path if provided, else auto-detect
    bool DiscoverMouse(device_path = "");     // Use path if provided, else auto-detect
    void Read(int& mouse_dx); // Read events, update keys, accumulate mouse
    bool CheckToggle();       // Detect Ctrl+M edge, return true if toggled
    void Grab(bool enable);   // EVIOCGRAB for exclusive access
    bool IsKeyPressed(int keycode) const;  // Encapsulated key state access
};

Explicit device usage:
  - If device_path provided: open it directly, no auto-detection
  - If empty: perform auto-detection with priority system

Keyboard auto-detection: enumerate /dev/input/event*, check name via EVIOCGNAME
  - Priority-based selection:
    * Priority 100: Actual keyboard devices (name contains " keyboard")
    * Priority 50:  Generic devices with "keyboard" in name
    * Priority 10:  Consumer Control, System Control devices
  - Selects highest priority keyboard automatically
  
Mouse auto-detection: enumerate /dev/input/event*, check REL_X via EVIOCGBIT
  - Excludes keyboard devices that have pointer capabilities
  - Priority-based selection to avoid touchpads/virtual devices:
    * Priority 100: Real mice ("mouse", "wireless device", "beken")
    * Priority 50:  Generic devices with REL_X
    * Priority 20:  Virtual mouse devices from touchpads (UNIW, ELAN, Synaptics)
    * Priority 10:  Touchpad devices
    * Priority 5:   Consumer Control, System Control devices
  - Selects highest priority device automatically
  
Events read non-blocking (O_NONBLOCK), all pending events consumed per cycle
Keys stored as bool array indexed by event.code (KEY_W, KEY_S, KEY_LEFTCTRL, etc.)
Key state accessed via IsKeyPressed() for encapsulation

GAMEPAD (gamepad.h/cpp)
-----------------------
class GamepadDevice {
    int fd;
    
    // State
    int16_t steering = 0;       // -32768 to 32767
    float throttle = 0.0f;      // 0.0 to 100.0
    float brake = 0.0f;         // 0.0 to 100.0
    std::map<std::string, bool> buttons;
    int8_t dpad_x = 0, dpad_y = 0;  // -1, 0, 1
    
    bool Create();  // Open /dev/uinput, setup Xbox 360 identity
    void UpdateSteering(int delta, int sens);  // Accumulative + clamped
    void UpdateThrottle(bool pressed);         // Ramp ±3.0 per frame
    void UpdateBrake(bool pressed);
    void UpdateButtons(const Input& input);
    void UpdateDPad(const Input& input);
    void SendState();
    void SendNeutral();  // All zeros
};

Virtual device: VID=0x045e, PID=0x028e, name="Xbox 360 Controller"
Axes (matching real Xbox 360 controller):
  - ABS_X:     Left stick X (steering, -32768 to 32767)
  - ABS_Y:     Left stick Y (unused, always 0)
  - ABS_RX:    Right stick X (unused, always 0)
  - ABS_RY:    Right stick Y (unused, always 0)
  - ABS_Z:     Left trigger (brake, 0-255)
  - ABS_RZ:    Right trigger (throttle, 0-255)
  - ABS_HAT0X/Y: D-Pad (-1, 0, 1)
Buttons: BTN_A/B/X/Y, BTN_TL/TR (bumpers), BTN_SELECT/START, 
         BTN_THUMBL/THUMBR (stick clicks), BTN_MODE (Xbox button)

DETECTION MODE (main.cpp)
-------------------------
Interactive device detection via --detect flag:
1. Opens all /dev/input/event* devices non-blocking
2. Checks capabilities via EVIOCGBIT:
   - has_keys: device has EV_KEY with KEY_A or KEY_SPACE (actual keyboard)
   - has_rel_x: device has EV_REL with REL_X (mouse movement)
3. Keyboard detection phase (5 seconds):
   - User prompted to type keys
   - Monitors all keyboard-capable devices
   - Counts key press events (EV_KEY with value=1)
   - Selects device with most key presses
4. Mouse detection phase (5 seconds):
   - User prompted to move mouse
   - Monitors all mouse-capable devices
   - Counts REL_X movement events
   - Selects device with most movements
5. Automatic config update:
   - Loads existing /etc/wheel-emulator.conf (creates if missing)
   - Calls config.UpdateDevices(kbd_path, mouse_path)
   - Updates keyboard= and mouse= lines in [devices] section
   - Writes updated config back to /etc/wheel-emulator.conf
6. Outputs detected devices and success/failure message

MAIN LOOP (main.cpp)
--------------------
bool input_enabled = false;  // Start disabled

while (true) {
    mouse_dx = 0;
    input.Read(mouse_dx);
    
    if (input.CheckToggle()) {
        input_enabled = !input_enabled;
        if (input_enabled)
            input.Grab(true);   // Grab devices when enabling
        else
            input.Grab(false);  // Ungrab devices when disabling
    }
    
    if (input_enabled) {
        gamepad.UpdateSteering(mouse_dx, config.sensitivity);
        gamepad.UpdateThrottle(input.IsKeyPressed(KEY_W));
        gamepad.UpdateBrake(input.IsKeyPressed(KEY_S));
        gamepad.UpdateButtons(input);
        gamepad.UpdateDPad(input);
        gamepad.SendState();
    } else {
        gamepad.SendNeutral();
    }
    
    usleep(1000);  // 1ms = 1000 Hz
}

=============================================================================
ALGORITHMS
=============================================================================

Steering (Accumulative, Linear):
  delta_steering = delta_x * (sensitivity / 100.0)
  new_steering = steering + delta_steering (as int32_t)
  steering = clamp(new_steering, -32768, 32767) (as int16_t)
  
  Note: Sensitivity is linear multiplier (1-100%):
  - At 5%: each pixel of mouse movement adds 0.05 to steering
  - At 100%: each pixel adds 1.0 to steering
  - Requires ~32768 pixels to reach full lock at 100% sensitivity
  - At 5% (recommended), requires ~655,000 pixels for full lock

Throttle/Brake (Analog Ramping):
  if pressed: value = min(100.0, value + 3.0)
  else:       value = max(0.0, value - 3.0)
  output = uint8_t(value * 2.55)

D-Pad:
  dpad_x = right - left
  dpad_y = down - up

Toggle Detection (Edge):
  both = keys[KEY_LEFTCTRL] && keys[KEY_M]
  if both && !prev_toggle: toggled = true
  prev_toggle = both

=============================================================================
INPUT MAPPINGS
=============================================================================

Mouse X → ABS_X (steering)
W → ABS_RZ (right trigger, throttle)
S → ABS_Z (left trigger, brake)
Arrow keys → ABS_HAT0X/Y (D-Pad)
Q/E/F/G/H → BTN_A/B/X/Y/LB (configurable via INI)
Ctrl+M → Toggle enable/disable
Ctrl+C → Exit

=============================================================================
USAGE
=============================================================================

First-time setup:
  sudo ./wheel-emulator --detect    # Interactive device detection
                                     # Automatically updates /etc/wheel-emulator.conf

Normal usage:
  sudo ./wheel-emulator              # Run with configured devices
  
Manual configuration:
  Edit /etc/wheel-emulator.conf:
    [devices]
    keyboard=/dev/input/event6
    mouse=/dev/input/event11

=============================================================================
BUILD SYSTEM
=============================================================================

MAKEFILE
--------
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Wextra -O2
TARGET = wheel-emulator
SOURCES = src/main.cpp src/config.cpp src/input.cpp src/gamepad.cpp
OBJECTS = $(SOURCES:.cpp=.o)

all: $(TARGET)

$(TARGET): $(OBJECTS)
	$(CXX) $(CXXFLAGS) -o $@ $^

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	rm -f $(OBJECTS) $(TARGET)

install: $(TARGET)
	install -m 755 $(TARGET) /usr/local/bin/

.PHONY: all clean install

Usage:
  make          - Build the executable
  make clean    - Remove build artifacts
  make install  - Install to /usr/local/bin (requires root)

=============================================================================

